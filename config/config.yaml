# Config file for the NYU Retinotopy Dataset.

display:
  figsize: [4, 4]
  dpi: 128
  plot_options:
    color: [0.75, 0.75, 1.0]
    linewidth: 2
    markersize: 1
    linestyle: "solid"
  fg_options:
    color: [1.0, 1.0, 1.0]
    markersize: 2

# In the init section, we want to make sure numpy and neuropythy are imported,
# and we want to make sure we have define a subject_path where we will load
# subjects from.
init: |
    # Import libraries.
    import neuropythy as ny, numpy as np
    from pathlib import Path
    # We load our data from this path, which we will need to mount inside the
    # docker container.
    data_path = Path('/data/derivatives')
    # This is the neuropythy mask of the occipital pole for making flatmaps.
    occpole_mask = ('parcellation', 43)
    # This is the key we use for visual area labels.
    label_key = dict(
        v1=1, v2=2, v3=3,
        hv4=4, vo1=5, vo2=6,
        v3a=7, v3b=8, ips0=9, lo1=10)

# We assume in this example that the libraries neuropythy and numpy have been
# imported (as ny and np respectively) in the init section (see below).
targets:
    # The Subject ID is selectable because we provide a list of explicit values.
    Subject ID:
      - sub-wlsubj119
      - sub-wlsubj127
      - sub-wlsubj136
      - sub-wlsubj137
      - sub-wlsubj143
      - sub-wlsubj144
      - sub-wlsubj145
      - sub-wlsubj146
      - sub-wlsubj147
      - sub-wlsubj148
      - sub-wlsubj149
      - sub-wlsubj150
      - sub-wlsubj151
      - sub-wlsubj152
      - sub-wlsubj153
      - sub-wlsubj154
      - sub-wlsubj155
      - sub-wlsubj156
      - sub-wlsubj157
      - sub-wlsubj158
      - sub-wlsubj159
      - sub-wlsubj160
      - sub-wlsubj161
      - sub-wlsubj162
      - sub-wlsubj163
      - sub-wlsubj164
      - sub-wlsubj165
      - sub-wlsubj166
      - sub-wlsubj167
      - sub-wlsubj168
      - sub-wlsubj170
      - sub-wlsubj171
      - sub-wlsubj172
      - sub-wlsubj173
      - sub-wlsubj174
      - sub-wlsubj175
      - sub-wlsubj176
    # Once we have established the subject ID, we can load the subject object,
    # which we will need for generating images.
    # This code block assumes that the `init` section defined the
    # `data_src` variable.
    subject: |
        subj = target['Subject ID']
        path = data_path / 'freesurfer' / subj
        return ny.freesurfer_subject(str(path))
    # The hemisphere is another selectable item because there are 2 of them.
    Hemisphere:
        - LH
        - RH
    # Cortex, which has a string, is again a lazy value defined by a code
    # snippet. This snippet extracts the Cortex object for the selected
    # hemisphere.
    cortex: |
        subj = target['Subject ID']
        h = target['Hemisphere'].lower()
        ctx = target['subject'].hemis[h]
        # Load the retinotopy also.
        path = data_path / 'prfvista' / subj / 'ses-nyu3t01'
        props = dict(
            polar_angle = ny.load(str(path / f"{h}.angle_adj.mgz")),
            theta = ny.load(str(path / f"{h}.angle.mgz")),
            eccentricity = ny.load(str(path / f"{h}.eccen.mgz")),
            x = ny.load(str(path / f"{h}.x.mgz")),
            y = ny.load(str(path / f"{h}.y.mgz")),
            radius = ny.load(str(path / f"{h}.sigma.mgz")),
            cod = ny.load(str(path / f"{h}.vexpl.mgz")))
        return ctx.with_prop(props)
    # Additionally, we create a flatmap projection for the hemisphere. Here we
    # make a projection of the occipital cortex.
    flatmap: |
        # Start by importing neuropythy.
        # Make a flatmap projection of the occipital cortex.
        c = target['cortex']
        return c.mask_flatmap(occpole_mask,
                              map_right='right',
                              radius=np.pi/2,
                              registration='native')
    # Finally, it's useful to have information about the image coordinates in
    # the target data, so we add these.
    xlim: |
        x = target['flatmap'].coordinates[0]
        return (np.min(x), np.max(x))
    ylim: |
        y = target['flatmap'].coordinates[1]
        return (np.min(y), np.max(y))
    projection_data: |
      proj = target['flatmap'].meta_data['projection']
      proj = proj.copy(mesh=None)
      return proj.normalize()
      
# When annotating V1-V3 using retinotopic maps; we need contours for the
# periphery and for V1, V2, and V3 boundaries. When drawn like this, they are
# all simple contours (not boundaries).
annotations:
  # V1 contours:
  V1 Foveal Point:
    type: point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V1 UVM (ventral):
    fixed_head: V1 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V1 LVM (dorsal):
    fixed_head: V1 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V1 Periphery:
    fixed_head:
      requires: V1 UVM (ventral)
      calculate: |
        return annotations['V1 UVM (ventral)'][-1,:]
    fixed_tail:
      requires: V1 LVM (dorsal)
      calculate: |
        return annotations['V1 LVM (dorsal)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  # V2 contours:
  V2 Foveal Point:
    type: point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V2 UVM (ventral):
    fixed_head: V2 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V2 LVM (dorsal):
    fixed_head: V2 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V2 Ventral Periphery:
    fixed_head:
      requires: V2 UVM (ventral)
      calculate: |
        return annotations['V2 UVM (ventral)'][-1,:]
    fixed_tail:
      requires: V1 UVM (ventral)
      calculate: |
        return annotations['V1 UVM (ventral)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V2 Dorsal Periphery:
    fixed_tail:
      requires: V2 LVM (dorsal)
      calculate: |
        return annotations['V2 LVM (dorsal)'][-1,:]
    fixed_head:
      requires: V1 LVM (dorsal)
      calculate: |
        return annotations['V1 LVM (dorsal)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  # V3 contours:
  V3 Foveal Point:
    type: point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3 UVM (ventral):
    fixed_head: V3 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3 LVM (dorsal):
    fixed_head: V3 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3 Ventral Periphery:
    fixed_head:
      requires: V3 UVM (ventral)
      calculate: |
        return annotations['V3 UVM (ventral)'][-1,:]
    fixed_tail:
      requires: V2 UVM (ventral)
      calculate: |
        return annotations['V2 UVM (ventral)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3 Dorsal Periphery:
    fixed_tail:
      requires: V3 LVM (dorsal)
      calculate: |
        return annotations['V3 LVM (dorsal)'][-1,:]
    fixed_head:
      requires: V2 LVM (dorsal)
      calculate: |
        return annotations['V2 LVM (dorsal)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  # Ventral Contours
  hV4 LVM (ventral-outer):
    fixed_head: V3 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  VO Outer:
    fixed_head:
      requires: V3 UVM (ventral)
      calculate: |
        return annotations['V3 UVM (ventral)'][-1,:]
    fixed_tail:
      requires: hV4 LVM (ventral-outer)
      calculate: |
        return annotations['hV4 LVM (ventral-outer)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  hV4-VO1 Boundary:
    - ["polar_angle", "eccentricity"]
    - ["curvature", "cod"]
  VO1-VO2 Boundary:
    - ["polar_angle", "eccentricity"]
    - ["curvature", "cod"]
  # Dorsal Contours
  V3a-V3b Outer:
    fixed_head:
      requires: V3 LVM (dorsal)
      calculate: |
        return annotations['V3 LVM (dorsal)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3a-V3b Inner:
    - ["polar_angle", "eccentricity"]
    - ["curvature", "cod"]
  IPS0 Outer:
    - ["polar_angle", "eccentricity"]
    - ["curvature", "cod"]
  LO1 Outer:
    fixed_head: V3 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]

figures:
    # We don't need an init block, but we do want to make sure the images all
    # have the xlim and ylim set correctly.
    term: |
        axes.set_xlim(target['xlim'])
        axes.set_ylim(target['ylim'])
        # We also want to put the projection data into the meta-data.
        meta_data['projection'] = target['projection_data']
    # The highlight images need some specific code to plot correctly.
    highlight_vm: |
        th = target['flatmap'].prop('theta')
        h = (1 - np.abs(np.cos(th)))**2
        ny.cortex_plot(target['flatmap'], color=h, axes=axes,
                       cmap='hot', vmin=0, vmax=1)
    highlight_hm: |
        th = target['flatmap'].prop('theta')
        h = (1 - np.abs(np.sin(th)))**2
        ny.cortex_plot(target['flatmap'], color=h, axes=axes,
                       cmap='hot', vmin=0, vmax=1)
    highlight_periphery: |
        eccen = target['flatmap'].prop('eccentricity')
        maxecc = np.nanpercentile(eccen, 95)
        hl = np.sqrt(np.abs(maxecc - eccen))*np.sqrt(maxecc)
        ny.cortex_plot(target['flatmap'], color=hl, axes=axes,
                       cmap='hot', vmax=0, vmin=maxecc)
    # The curvature is very straightforward.
    curvature: |
        ny.cortex_plot(target['flatmap'])
    # The COD needs some special parameters also.
    cod: |
        ny.cortex_plot(target['flatmap'], color='cod', axes=axes, cmap='hot',
                       vmin=0, vmax=1)
    # The rest are PRF properties.
    _: |
        ny.cortex_plot(target['flatmap'], color=key, axes=axes)

figures:
  term: |
    xy = target['flatmap'].coordinates
    (xmin,ymin) = np.min(xy, axis=1)
    (xmax,ymax) = np.max(xy, axis=1)
    axes.set_xlim((xmin,xmax))
    axes.set_ylim((ymin,ymax))
  polar_angle: |
    ny.cortex_plot(target['flatmap'], color="polar_angle", axes=axes)
  eccentricity: |
    ny.cortex_plot(target['flatmap'], color="eccentricity", axes=axes)
  cod: |
    ny.cortex_plot(target['flatmap'], color="cod", axes=axes,
                   cmap='hot', vmin=0, vmax=1)
  curvature: |
    ny.cortex_plot(target['flatmap'], axes=axes)

review: |
  #from annotate import watershed_contours
  #im = watershed_contours(annotations.values(), max_depth=1)
  #axes.imshow(im, cmap='hsv', vmin=0, vmax=1.5*np.max(im))
  import numpy as np
  h = target['Hemisphere'].lower()
  # V1:
  v1uvm = annotations['V1 UVM (ventral)']
  v1lvm = annotations['V1 LVM (dorsal)']
  v1per = annotations['V1 Periphery']
  v1pol = np.vstack([v1uvm, v1per, np.flipud(v1lvm)])
  # V2:
  v2uvm = annotations['V2 UVM (ventral)']
  v2lvm = annotations['V2 LVM (dorsal)']
  v2pev = annotations['V2 Ventral Periphery']
  v2ped = annotations['V2 Dorsal Periphery']
  v2pol = np.vstack(
      [v2uvm, v2pev, np.flipud(v1uvm), v1lvm, v2ped, np.flipud(v2lvm)])
  # V3:
  v3uvm = annotations['V3 UVM (ventral)']
  v3lvm = annotations['V3 LVM (dorsal)']
  v3pev = annotations['V3 Ventral Periphery']
  v3ped = annotations['V3 Dorsal Periphery']
  v3pol = np.vstack(
      [v3uvm, v3pev, np.flipud(v2uvm), v2lvm, np.flipud(v3ped), np.flipud(v3lvm)])
  # hV4, VO1, VO2:
  hv4out = annotations['hV4 LVM (ventral-outer)']
  voout = annotations['VO Outer']
  hv4vo = annotations['hV4-VO1 Boundary']
  vo1vo2 = annotations['VO1-VO2 Boundary']
  from nyunei.proc import proc_ventral
  pols_vent = proc_ventral(h, hv4out, voout, hv4vo, vo1vo2, v3uvm)
  # V3a/b, IPS0, LO1:
  v3_dorsal = annotations['V3 LVM (dorsal)']
  v3ab_outer = annotations['V3a-V3b Outer']
  v3ab_inner = annotations['V3a-V3b Inner']
  ips0_outer = annotations['IPS0 Outer']
  lo1_outer = annotations['LO1 Outer']
  from nyunei.proc import proc_dorsal
  pols_dors = proc_dorsal(
      h, v3ab_outer, v3ab_inner, ips0_outer, lo1_outer, v3_dorsal)
  # Turn these into traces:
  pols = {'V1': v1pol, 'V2': v2pol, 'V3': v3pol}
  pols.update(pols_vent)
  pols.update(pols_dors)
  fmap = target['flatmap']
  traces = {
      k: ny.path_trace(fmap, pol.T, closed=True)
      for (k, pol) in pols.items()}
  # Convert the path traces into paths then into labels:
  cortex = target['cortex']
  paths = {k: tr.to_path(cortex) for (k,tr) in traces.items()}
  labels = np.zeros(cortex.vertex_count, dtype=int)
  for (k,p) in paths.items():
      lbl = p.label > 0.5
      if np.sum(lbl) > np.sum(~lbl):
        lbl = p.label < 0.5
      labels[lbl] = label_key[k.lower()]
  fmap_labels = labels[fmap.labels]
  # If the user saves the contours, we want to save these labels.
  save_hooks['labels.mgz'] = lambda filename: ny.save(filename, labels)
  # Plot the results:
  ny.cortex_plot(
      fmap,
      color=fmap_labels,
      cmap='rainbow',
      mask=(fmap_labels > 0),
      axes=axes,
      alpha=0.5)
  axes.axis('equal')
  axes.axis('off')

