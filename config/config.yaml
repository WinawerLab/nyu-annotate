# Config file for the NYU Retinotopy Dataset.

display:
  figsize: [4, 4]
  dpi: 128
  plot_options:
    color: [0.75, 0.75, 1.0]
    linewidth: 2
    markersize: 1
    linestyle: "solid"
  fg_options:
    color: [1.0, 1.0, 1.0]
    markersize: 2

# In the init section, we want to make sure numpy and neuropythy are imported,
# and we want to make sure we have define a subject_path where we will load
# subjects from.
init: |
    # Import libraries.
    import neuropythy as ny, numpy as np
    from pathlib import Path
    # Declare where the dataset lives (inside the running docker container):
    data_path = Path('/data/derivatives')
    # This is the neuropythy mask of the occipital pole for making flatmaps.
    occpole_mask = ('parcellation', 43)

# We assume in this example that the libraries neuropythy and numpy have been
# imported (as ny and np respectively) in the init section (see below).
targets:
    # The Subject ID is selectable because there are 3 of them.
    Subject ID:
       - sub-wlsubj119
       - sub-wlsubj127
       - sub-wlsubj136
       - sub-wlsubj137
       - sub-wlsubj143
       - sub-wlsubj144
       - sub-wlsubj145
       - sub-wlsubj146
       - sub-wlsubj147
       - sub-wlsubj148
       - sub-wlsubj149
       - sub-wlsubj150
       - sub-wlsubj151
       - sub-wlsubj152
       - sub-wlsubj153
       - sub-wlsubj154
       - sub-wlsubj155
       - sub-wlsubj156
       - sub-wlsubj157
       - sub-wlsubj158
       - sub-wlsubj159
       - sub-wlsubj160
       - sub-wlsubj162
       - sub-wlsubj163
       - sub-wlsubj164
       - sub-wlsubj165
       - sub-wlsubj166
       - sub-wlsubj167
       - sub-wlsubj168
       - sub-wlsubj169
       - sub-wlsubj170
       - sub-wlsubj171
       - sub-wlsubj172
       - sub-wlsubj173
       - sub-wlsubj174
       - sub-wlsubj175
       - sub-wlsubj176
    # Once we have established the subject ID, we can load the subject object,
    # which we will need for generating images.
    # This code block assumes that the `init` section defined the
    # `data_src` variable.
    subject: |
        subj = target['Subject ID']
        path = data_path / 'freesurfer' / subj
        return ny.freesurfer_subject(str(path))
    # The hemisphere is another selectable item because there are 2 of them.
    Hemisphere:
        - LH
        - RH
    # Cortex, which has a string, is again a lazy value defined by a code
    # snippet. This snippet extracts the Cortex object for the selected
    # hemisphere.
    cortex: |
        subj = target['Subject ID']
        h = target['Hemisphere'].lower()
        ctx = target['subject'].hemis[h]
        # Load the retinotopy also.
        path = data_path / 'prfvista' / subj / 'ses-nyu3t01'
        props = dict(
            polar_angle = ny.load(str(path / f"{h}.angle_adj.mgz")),
            theta = ny.load(str(path / f"{h}.angle.mgz")),
            eccentricity = ny.load(str(path / f"{h}.eccen.mgz")),
            x = ny.load(str(path / f"{h}.x.mgz")),
            y = ny.load(str(path / f"{h}.y.mgz")),
            radius = ny.load(str(path / f"{h}.sigma.mgz")),
            cod = ny.load(str(path / f"{h}.vexpl.mgz")))
        return ctx.with_prop(props)
    # Additionally, we create a flatmap projection for the hemisphere. Here we
    # make a projection of the occipital cortex.
    flatmap: |
        # Start by importing neuropythy.
        # Make a flatmap projection of the occipital cortex.
        c = target['cortex']
        return c.mask_flatmap(occpole_mask,
                              map_right='right',
                              radius=np.pi/2,
                              registration='native')
    # Finally, it's useful to have information about the image coordinates in
    # the target data, so we add these.
    xlim: |
        x = target['flatmap'].coordinates[0]
        return (np.min(x), np.max(x))
    ylim: |
        y = target['flatmap'].coordinates[1]
        return (np.min(y), np.max(y))
    projection_data: |
      proj = target['flatmap'].meta_data['projection']
      proj = proj.copy(mesh=None)
      return proj.normalize()
      
# When annotating V1-V3 using retinotopic maps; we need contours for the
# periphery and for V1, V2, and V3 boundaries. When drawn like this, they are
# all simple contours (not boundaries).
annotations:
  # V1 contours:
  V1 Foveal Point:
    type: point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V1 UVM (ventral):
    fixed_head: V1 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V1 LVM (dorsal):
    fixed_head: V1 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V1 Periphery:
    fixed_head:
      requires: V1 UVM (ventral)
      calculate: |
        return annotations['V1 UVM (ventral)'][-1,:]
    fixed_tail:
      requires: V1 LVM (dorsal)
      calculate: |
        return annotations['V1 LVM (dorsal)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  # V2 contours:
  V2 Foveal Point:
    type: point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V2 UVM (ventral):
    fixed_head: V2 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V2 LVM (dorsal):
    fixed_head: V2 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V2 Ventral Periphery:
    fixed_head:
      requires: V2 UVM (ventral)
      calculate: |
        return annotations['V2 UVM (ventral)'][-1,:]
    fixed_tail:
      requires: V1 UVM (ventral)
      calculate: |
        return annotations['V1 UVM (ventral)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V2 Dorsal Periphery:
    fixed_tail:
      requires: V2 LVM (dorsal)
      calculate: |
        return annotations['V2 LVM (dorsal)'][-1,:]
    fixed_head:
      requires: V1 LVM (dorsal)
      calculate: |
        return annotations['V1 LVM (dorsal)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  # V3 contours:
  V3 Foveal Point:
    type: point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3 UVM (ventral):
    fixed_head: V3 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3 LVM (dorsal):
    fixed_head: V3 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3 Ventral Periphery:
    fixed_head:
      requires: V3 UVM (ventral)
      calculate: |
        return annotations['V3 UVM (ventral)'][-1,:]
    fixed_tail:
      requires: V2 UVM (ventral)
      calculate: |
        return annotations['V2 UVM (ventral)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3 Dorsal Periphery:
    fixed_tail:
      requires: V3 LVM (dorsal)
      calculate: |
        return annotations['V3 LVM (dorsal)'][-1,:]
    fixed_head:
      requires: V2 LVM (dorsal)
      calculate: |
        return annotations['V2 LVM (dorsal)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  # Ventral Contours
  hV4 LVM (ventral-outer):
    fixed_head: V3 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  VO Outer:
    fixed_head:
      requires: V3 UVM (ventral)
      calculate: |
        return annotations['V3 UVM (ventral)'][-1,:]
    fixed_tail:
      requires: hV4 LVM (ventral-outer)
      calculate: |
        return annotations['hV4 LVM (ventral-outer)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  hV4-VO1 Boundary:
    - ["polar_angle", "eccentricity"]
    - ["curvature", "cod"]
  VO1-VO2 Boundary:
    - ["polar_angle", "eccentricity"]
    - ["curvature", "cod"]
  # Dorsal Contours
  V3a-V3b Outer:
    fixed_head:
      requires: V3 LVM (dorsal)
      calculate: |
        return annotations['V3 LVM (dorsal)'][-1,:]
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]
  V3a-V3b Inner:
    - ["polar_angle", "eccentricity"]
    - ["curvature", "cod"]
  IPS0 Outer:
    - ["polar_angle", "eccentricity"]
    - ["curvature", "cod"]
  LO1 Outer:
    fixed_head: V3 Foveal Point
    grid:
      - ["polar_angle", "eccentricity"]
      - ["curvature", "cod"]

figures:
    # We don't need an init block, but we do want to make sure the images all
    # have the xlim and ylim set correctly.
    term: |
        axes.set_xlim(target['xlim'])
        axes.set_ylim(target['ylim'])
        # We also want to put the projection data into the meta-data.
        meta_data['projection'] = target['projection_data']
    # The highlight images need some specific code to plot correctly.
    highlight_vm: |
        th = target['flatmap'].prop('theta')
        h = (1 - np.abs(np.cos(th)))**2
        ny.cortex_plot(target['flatmap'], color=h, axes=axes,
                       cmap='hot', vmin=0, vmax=1)
    highlight_hm: |
        th = target['flatmap'].prop('theta')
        h = (1 - np.abs(np.sin(th)))**2
        ny.cortex_plot(target['flatmap'], color=h, axes=axes,
                       cmap='hot', vmin=0, vmax=1)
    highlight_periphery: |
        eccen = target['flatmap'].prop('eccentricity')
        maxecc = np.nanpercentile(eccen, 95)
        hl = np.sqrt(np.abs(maxecc - eccen))*np.sqrt(maxecc)
        ny.cortex_plot(target['flatmap'], color=hl, axes=axes,
                       cmap='hot', vmax=0, vmin=maxecc)
    # The curvature is very straightforward.
    curvature: |
        ny.cortex_plot(target['flatmap'])
    # The COD needs some special parameters also.
    cod: |
        ny.cortex_plot(target['flatmap'], color='cod', axes=axes, cmap='hot',
                       vmin=0, vmax=1)
    # We also want to have thresholded versions of these plots.
    polar_angle_thresh: |
        ny.cortex_plot(target['flatmap'], color='polar_angle', axes=axes,
                       mash=('cod', 0.1, 1), cmap='hot', vmin=0, vmax=1)
    eccentricity_thresh: |
        ny.cortex_plot(target['flatmap'], color='eccentricity', axes=axes,
                       mash=('cod', 0.1, 1), cmap='hot', vmin=0, vmax=1)
    # The rest are PRF properties.
    _: |
        ny.cortex_plot(target['flatmap'], color=key, axes=axes)

review: |
  import numpy as np
  # V1:
  v1uvm = annotations['V1 UVM (ventral)']
  v1lvm = annotations['V1 LVM (dorsal)']
  v1per = annotations['V1 Periphery']
  v1pol = np.vstack([v1uvm, v1per, np.flipud(v1lvm)])
  # V2:
  v2uvm = annotations['V2 UVM (ventral)']
  v2lvm = annotations['V2 LVM (dorsal)']
  v2pev = annotations['V2 Ventral Periphery']
  v2ped = annotations['V2 Dorsal Periphery']
  v2pol = np.vstack(
      [v2uvm, v2pev, np.flipud(v1uvm), v1lvm, v2ped, np.flipud(v2lvm)])
  # V3:
  v3uvm = annotations['V3 UVM (ventral)']
  v3lvm = annotations['V3 LVM (dorsal)']
  v3pev = annotations['V3 Ventral Periphery']
  v3ped = annotations['V3 Dorsal Periphery']
  v3pol = np.vstack(
      [v3uvm, v3pev, np.flipud(v2uvm), v2lvm, v3ped, np.flipud(v3lvm)])
  # Turn these into traces:
  fmap = target['flatmap']
  v1_trace = ny.path_trace(fmap, v1pol.T, closed=True)
  v2_trace = ny.path_trace(fmap, v2pol.T, closed=True)
  v3_trace = ny.path_trace(fmap, v3pol.T, closed=True)
  # Convert the path traces into paths then into labels:
  cortex = target['cortex']
  v1_path = v1_trace.to_path(cortex)
  v2_path = v2_trace.to_path(cortex)
  v3_path = v3_trace.to_path(cortex)
  v1 = v1_path.label > 0.5
  v2 = v2_path.label > 0.5
  v3 = v3_path.label > 0.5
  if np.sum(v1) > np.sum(~v1):
    v1 = ~v1
  if np.sum(v2) > np.sum(~v2):
    v2 = ~v2
  if np.sum(v3) > np.sum(~v3):
    v3 = ~v3
  labels = np.zeros(cortex.vertex_count, dtype=int)
  labels[v1] = 1
  labels[v2] = 2
  labels[v3] = 3
  fmap_labels = labels[fmap.labels]
  # If the user saves the contours, we want to save these labels.
  save_hooks['v123-labels.mgz'] = lambda filename: ny.save(filename, labels)
  # Plot the results:
  ny.cortex_plot(
      fmap,
      color=fmap_labels,
      cmap='rainbow',
      mask=(fmap_labels > 0),
      axes=axes,
      alpha=0.5)
  axes.axis('equal')
  axes.axis('off')
